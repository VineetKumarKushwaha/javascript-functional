(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.functional = {})));
}(this, (function (exports) { 'use strict';

    // Setoid
    // Taken from haskell http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Eq.html
    /*
    Defintion:-


    Rules:-
        Reflexivity
            x == x = True
        Symmetry
            x == y = y == x
        Transitivity
            if x == y && y == z = True, then x == z = True

    */
    const equal = (a, b) => {
        return a === b;
    };
    const stringEquality = { isEqual: equal };
    const numberEquality = { isEqual: equal };
    const booleanEquality = { isEqual: equal };
    //Combinator pattern
    /*
        there is some type T,
        some "primitive" values of type T,
        and some "combinators" which can combine values of type T in various ways to build up more complex values of type T
    */
    function doMultipleEqualityCheck(equals) {
        return {
            isEqual: (x, y) => equals(x, y)
        };
    }
    const equalityCombinator = (obj) => {
        return doMultipleEqualityCheck((x, y) => Object.keys(obj).every(k => obj[k].isEqual(x[k], y[k])));
    };
    // const vectorEquality = equalityCombinator({
    //     x: numberEquality,
    //     y: numberEquality
    // })
    // vectorEquality.isEqual({x: 238, y: 324}, {x: 394, y: 342432})
    const contraMap = (f, fa) => doMultipleEqualityCheck((x, y) => fa.isEqual(f(x), f(y)));
    // type User = {
    //     userId: number
    //     name: string
    // }
    // const eqUser = contraMap((user: User) => user.userId, numberEquality)
    // eqUser.isEqual({ userId: 324324, name: ""}, { userId: 324324, name: "" })
    // TODO: need to implement contravariant functor
    // export contraMap = (fa, f) => (x, y) => fa.equals(f(x), f(y))
    // Make it Contravariant
    // contramap
    // will do with functors.
    // export type Kind<URI extends URIS, A> = URI extends URIS ? URItoKind<A>[URI] : any
    // export interface URItoKind<A> {}
    // export type URIS = keyof URItoKind<any>
    //   export interface Contravariant1<F extends URIS> {
    //     readonly URI: F
    //     readonly contramap: <A, B>(fa: Kind<F, A>, f: (b: B) => A) => Kind<F, B>
    //   }
    // export const URI = 'Eq'
    // export type URI = typeof URI
    // export const eq: Contravariant1<URI> = {
    //     URI,
    //     contramap: (fa, f) => fromEquals((x, y) => fa.equals(f(x), f(y)))
    //   }
    // contramap: (fa, f) => fromEquals((x, y) => fa.equals(f(x), f(y)))

    var equality = /*#__PURE__*/Object.freeze({
        stringEquality: stringEquality,
        numberEquality: numberEquality,
        booleanEquality: booleanEquality,
        equalityCombinator: equalityCombinator,
        contraMap: contraMap
    });

    /*
        1) Reflexivity
        2) Antisymmetry
        3) Transitivity

    */
    const compare = (x, y) => (x < y ? -1 : x > y ? 1 : 0);
    const numberOrd = {
        isEqual: (x, y) => x === y,
        compare: (x, y) => compare(x, y),
        min: (x, y) => Math.min(x, y),
        max: (x, y) => Math.max(x, y)
    };
    const stringOrd = {
        isEqual: (x, y) => x === y,
        compare: (x, y) => compare(x.toLowerCase(), y.toLowerCase()),
        min: (x, y) => compare(x.toLowerCase(), y.toLowerCase()) ? x : y,
        max: (x, y) => compare(x.toLowerCase(), y.toLowerCase()) ? y : x
    };
    const booleanOrd = {
        isEqual: (x, y) => x === y,
        compare: (x, y) => compare(x, y),
        max: _ => true,
        min: _ => false
    };
    /** Combinator pattern */
    const min = (ord) => (x, y) => ord.compare(x, y) === -1 ? x : y;
    const max = (ord) => (x, y) => ord.compare(x, y) === -1 ? y : x;
    function fnOrdering(compare) {
        return {
            min: (x, y) => compare(x, y) === -1 ? x : y,
            max: (x, y) => compare(x, y) === -1 ? y : x,
            isEqual: (x, y) => compare(x, y) === 0,
            compare: (x, y) => compare(x, y)
        };
    }
    const contraMap$1 = (f, fa) => fnOrdering((x, y) => fa.compare(f(x), f(y)));
    const between = (O) => (low, high) => (x) => !(O.compare(low, x) === -1 || O.compare(high, x) === 1);
    const clamp = (O) => (low, high) => (x) => O.max(O.min(x, high), low);
    /*
       getDualOrd reverse the sequence
    */

    var ordering = /*#__PURE__*/Object.freeze({
        numberOrd: numberOrd,
        stringOrd: stringOrd,
        booleanOrd: booleanOrd,
        min: min,
        max: max,
        contraMap: contraMap$1,
        between: between,
        clamp: clamp
    });

    // Law:-
    /**
     * Associativity
     */
    const semigroupSum = {
        concat: (x, y) => x + y
    };
    const semigroupProduct = {
        concat: (x, y) => x * y
    };
    const semigroupString = {
        concat: (x, y) => x + y
    };
    const semigroupArray = {
        concat: (x, y) => x.concat(y)
    };
    function getFirstSemigroup() {
        return { concat: (a) => a };
    }
    function getLastSemigroup() {
        return { concat: (_, y) => y };
    }
    function getMinThroughSemigroup(O) {
        return {
            concat: min(O)
        };
    }
    function getMaxThroughSemigroup(O) {
        return {
            concat: max(O)
        };
    }
    function getObjectSemigroup() {
        return {
            concat: (x, y) => Object.assign({}, x, y)
        };
    }
    //Combinator pattern
    /*
        there is some type T,
        some "primitive" values of type T,
        and some "combinators" which can combine values of type T in various ways to build up more complex values of type T
    */
    function fromConcat(concat) {
        return {
            concat: (x, y) => concat(x, y)
        };
    }
    const getSemiGroupFromObject = (obj) => {
        return fromConcat((x, y) => {
            const r = {};
            for (const key of Object.keys(obj)) {
                r[key] = obj[key].concat(x[key], y[key]);
            }
            return r;
        });
    };
    const getFunctionSemigroup = (S) => {
        return ({
            concat: (f, g) => a => S.concat(f(a), g(a))
        });
    };
    const semigroupAny = {
        concat: (x, y) => x || y
    };
    const semigroupAll = {
        concat: (x, y) => x && y
    };
    const fold = (S) => {
        return (a, as) => as.reduce(S.concat, a);
    };
    // Maybe
    /**
     *  Nothing Nothing -> Nothing
     *  Nothing Just(10) -> Nothing
     *  Just(20) Nothing -> Nothing
     *  Just(20) Just(30) -> what would be the value
     */

    var semigroup = /*#__PURE__*/Object.freeze({
        semigroupSum: semigroupSum,
        semigroupProduct: semigroupProduct,
        semigroupString: semigroupString,
        semigroupArray: semigroupArray,
        getFirstSemigroup: getFirstSemigroup,
        getLastSemigroup: getLastSemigroup,
        getMinThroughSemigroup: getMinThroughSemigroup,
        getMaxThroughSemigroup: getMaxThroughSemigroup,
        getObjectSemigroup: getObjectSemigroup,
        getSemiGroupFromObject: getSemiGroupFromObject,
        getFunctionSemigroup: getFunctionSemigroup,
        semigroupAny: semigroupAny,
        semigroupAll: semigroupAll,
        fold: fold
    });

    /**
     *  Law:-
     *  Associativity
     *  Right identity: concat(x, empty) = x, for all x in A
     *  Left identity: concat(empty, x) = x, for all x in A
    */
    const monoidSum = {
        concat: (x, y) => x + y,
        identity: 0
    };
    const monoidProduct = {
        concat: (x, y) => x * y,
        identity: 1
    };
    const monoidString = {
        concat: (x, y) => x + y,
        identity: ""
    };
    const monoidAll = {
        concat: (x, y) => x && y,
        identity: true
    };
    const monoidAny = {
        concat: (x, y) => x || y,
        identity: false
    };
    /**
     *
     * All semigroup are not Monoids
     * const semigroupSpace: Semigroup<string> = {
            concat: (x, y) => x + ' ' + y
        }
        We can't find an empty value such that concat(x, empty) = x.
     */
    //Combinator pattern
    /*
        there is some type T,
        some "primitive" values of type T,
        and some "combinators" which can combine values of type T in various ways to build up more complex values of type T
    */
    const getMonoidFromObject = (obj) => {
        const empty = {};
        for (const key of Object.keys(obj)) {
            empty[key] = obj[key].identity;
        }
        return {
            concat: getSemiGroupFromObject(obj).concat,
            identity: empty
        };
    };
    const fold$1 = (mon) => {
        return (as) => fold(mon)(mon.identity, as);
    };
    const getFunctionMonoid = (mon) => {
        return ({
            concat: getFunctionSemigroup(mon).concat,
            identity: () => mon.identity
        });
    };
    function identity(a) {
        return a;
    }
    const getEndomorphismMonoid = (a) => {
        return {
            concat: (x, y) => a => x(y(a)),
            identity: identity
        };
    };

    var monoid = /*#__PURE__*/Object.freeze({
        monoidSum: monoidSum,
        monoidProduct: monoidProduct,
        monoidString: monoidString,
        monoidAll: monoidAll,
        monoidAny: monoidAny,
        getMonoidFromObject: getMonoidFromObject,
        fold: fold$1,
        getFunctionMonoid: getFunctionMonoid,
        identity: identity,
        getEndomorphismMonoid: getEndomorphismMonoid
    });

    /**
     *
     * Functors
     *
     */
    const Nothing = { _: 'None' };
    const Just = (a) => {
        return { _: 'Just', value: a };
    };
    function isExist(fa) {
        return fa._ === 'Just';
    }
    function isNone(fa) {
        return fa._ === 'None';
    }
    function fold$2(onNone, onSome) {
        return ma => (isNone(ma) ? onNone() : onSome(ma.value));
    }
    function fromNullable(a) {
        return a == null ? Nothing : Just(a);
    }
    function toNullable(ma) {
        return isNone(ma) ? null : ma.value;
    }
    // export const map: <A, B>(ma: A, f: (A)) => (isNone(ma) ? none : some(f(ma.value)))

    var maybe = /*#__PURE__*/Object.freeze({
        Nothing: Nothing,
        Just: Just,
        isExist: isExist,
        isNone: isNone,
        fold: fold$2,
        fromNullable: fromNullable,
        toNullable: toNullable
    });

    exports.Equality = equality;
    exports.Ord = ordering;
    exports.Semigroup = semigroup;
    exports.Monoid = monoid;
    exports.Maybe = maybe;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
